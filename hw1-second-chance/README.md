# Haskell: ДЗ 1 - Блок 6: Парсер-комбинаторы

[![MIT license](https://img.shields.io/badge/license-MIT-blue.svg)](https://github.com/komour/fp-course/blob/master/hw1-second-chance/LICENSE)

Это блок самый важный в этом домашнем задании. Реализация всех упражнений из этого блока поможет понять, как устроены парсер-комбинаторы, а это важно, потому что они крайне полезны на практике. Перед решением заданий убедитесь, что вы осознали материал лекции и можете прорешать базовые упражнения по следующим ссылкам:

* [Parser Combinators: Basics](http://www.seas.upenn.edu/~cis194/spring13/hw/10-applicative.pdf)
* [Parser Combinators: Implementing simple parser](http://www.seas.upenn.edu/~cis194/spring13/hw/11-applicative2.pdf)

Основная часть упражнений оттуда всё равно является частью этого домашнего задания.

**Тесты:** в заданиях этого блока необходимо написать несколько юнит-тестов при помощи `hspec`. Property-based тесты по желанию.

### Задание 1: Copy-paste

Имеется тип простого парсер-комбинатора:

```haskell=
data Parser s a = Parser { runParser :: [s] -> Maybe (a, [s]) }
```

В отличие от парсера предложенного на практике, он может работать не только со строкой, но и с любым потоком данных. Реализуйте вручную инстансы `Functor`, `Applicative`, `Monad` и `Alternative` для этого парсера.

### Задание 2: Базовые комбинаторы

Реализуйте следующие базовые комбинаторы:

1. `ok` --- парсер никогда не падает и не поглащает инпут.
2. `eof` --- проверяет, что парсер дошёл до конца потока данных (иначе падает).
3. `satisfy` --- парсер принимает предикат на элемент потока, и возвращает элемент, поглащая его из потока, если предикат на элемент равен `True`, иначе падает.
4. `element` и `stream` --- парсят один или несколько элементов потока (как `char` и `string`).